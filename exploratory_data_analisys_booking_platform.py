# -*- coding: utf-8 -*-
"""exploratory_data_analisys_booking_platform.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UpVplceYK480nBDAXep9Erjj30SaaCAd

## Introduction

This is some analisys I did over data from a hotel booking platform.

These are the tables I'm going to use:

Data sources:
1. Clicks data (992,338 records): A sample of paid clicks to partner sites on Desktop & Mobile that the platform receives over a three week span.
2. Bookings data (24,640 records): All the hotel reservations that were made as a result of the clicks above (not all clicks convert to a booking, and some partners may not provide us with booking information).

Bookings data description:

Column,Type,Comment

*   file_key,varchar,"unique identifier of click that resulted in booking"
*   hotel_id,integer,"unique identifier of hotel property"
*   client_type,varchar,"client used by hotel shopper to make reservation"
*   provider_id,integer,"unique identifier of partner (advertiser)"
*   cc_cpc,integer,"click cost in cents"
*   device_type,varchar,"device type used to make hotel reservation"
*   paid_cpc,integer,""
*   attempted_cpc,integer,""
*   user_country_name,varchar,"country where the hotel shopper is browsing from"
*   uid,varchar,"unique identifier of a booking"
*   length_of_stay,integer,"number of nights"
*   check_in,varchar,"check in date of the hotel reservation"
*   check_out,varchar,"check out date of the hotel reservation"
*   gbv_usd,double,"gross booking value in dollars"
*   conversion_date,varchar,"date that the reservation occured"
*   conversion_hour,integer,"hour of the day that the reservation occured"

Clicks data description

Column,Type,Comment

*   provider_id,integer,"unique identifier of partner (advertiser)"
*   hotel_id,integer,"unique identifier of hotel property"
*   hotel_geo_name,varchar,"describes hotel geography page of this property"
*   hotel_country_id,integer,"unique identifier for hotel's country"
*   hotel_country_name,varchar,"hotel's country"
*   user_country_name,varchar,"country where the hotel shopper is browsing from"
*   device_type,varchar,"device type used to make hotel reservation"
*   click_file_key,varchar,"unique identifier of click that resulted in booking"
*   click_revenue_dollars,"decimal(16,2)","cost per click paid to the platform by the partner whose offer was clicked"
*   rooms,integer,"number of rooms in hotel search"
*   guests,integer,"number of guest in hotel search"
*   checkin_date,varchar,"check in date in hotel search"
*   checkout_date,varchar,"check out date in hotel search"
*   length_of_stay,integer,"number of nights in hotel search"
*   days_out,integer,"number of days between hotel search and check in day"
*   user_date_type,varchar,"indicates whether check in and check out dates were entered by user or automatically by the platform"
*   is_member_signed_in,boolean,"indicates whether user was signed in Tripadvisor"
*   bid_multiplier,"decimal(20,6)","total bid multiplier effective for the click"
*   bid_multiplierdetail,varchar,"Shows all considered multipliers"
*   ds,varchar,"date stamp when the click occured"

Background

At the booking platoform, the partners (hotel booking sites) participate in auctions to advertise hotel properties to the platform's users (otherwise known as shoppers). When a shopper browses a hotel, multiple booking sites will compete for the main placement (View Deal button) for that hotel.

Example, hotels in Boston:
The partner that wins the auction (and thus, has the main placement) usually receives most of the clicks for the hotel. Upon clicking a partner link, the user is redirected to the partner site where they can complete the booking and reserve a room at this hotel.

The platform records the clicks that take a hotel shopper to the partner’s website, and some partners will send the platform any reservation data (bookings) that is tied back to the initial click. Therefore, we know when a click converts to a hotel booking (in most cases!).
Example of a typical flow:
1. Hotel shopper browses site
2. Shopper clicks on partner’s hotel link & partner pays the platform the click cost (identified as click_revenue_dollars in the data source) (clicks data source)
3. Shopper is redirected to partner’s booking site
4. Shopper may or may not complete the hotel room booking
5. Partner may or may not provide booking data back to the platform (bookings source)

# Loading data and importing libraries
"""

#importing libraries
import pandas as pd
import numpy as np
from statistics import mean
import matplotlib.pyplot as plt
import datetime as dt
import seaborn as sns

#reading the Booking Data file into a csv
bookings = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/newtest/Test data/booking_data.txt"
                       ,header = None)

#including a header to the Booking Data file
bookings.columns = ['file_key', 'hotel_id', 'client_type','provider_id','cc_cpc','device_type','paid_cpc','attempted_cpc','user_country_name','uid','length_of_stay','check_in','check_out','gbv_usd','conversion_date','conversion_hour']

#taking a first look at the bookings dataframe
bookings.info()

#saving the bookings dataframe into a csv file
bookings.to_csv('booking_data.csv',
                index = None)

#reading the Click Data file into csv
clicks = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/newtest/Test data/click_data.txt"
                       ,header = None)

#including a header to the clicks dataframe
clicks.columns = ['provider_id','hotel_id','hotel_geo_name','hotel_country_id','hotel_country_name','user_country_name','device_type','click_file_key','click_revenue_dollars','rooms','guests','checkin_date','checkout_date','length_of_stay','days_out','user_date_type','is_member_signed_in','bid_multiplier','bid_multiplierdetail','ds']

clicks.info()

"""# What is the Average GBV (Gross Booking Value) in Australia?"""

#For this task, we'll work with the bookings dataframe
bookings.head()

#The columns necessary for this exercise are the following:
bookings[["gbv_usd","user_country_name"]]

#First step is to select only the gbv values corresponding to Australia
q1a = bookings[["gbv_usd"]].loc[bookings['user_country_name'] == "Australia"]

print('\nResult dataframe :\n', q1a)

#Now, we should replace all the NaN with a 0, this is how we'll be able to apply mathematical functions to our new dataframe
q1a["gbv_usd"] = q1a["gbv_usd"].replace(np.nan, 0)
print(q1a)

#Here is the average GBV:
q1a_avg = np.average(q1a)
print(round(q1a_avg,3))

#I felt like this avg result is a bit weird, so I decided to explore more and used a describe funtion to get more info

desc1 = q1a.describe()

print(round(desc1,3))

"""The average GBV may not be an 100% reliable metric for this specific dataframe, as it's values have a high standard variation.
I'd suggest the client to apply a segmented approach to this specific case, dividing it initially into 3 parts, 25% (the smaller values), 50% and over 75% (the highest values), just like in the results above, this apporach may provide us more reliable insights.

# From which device type do we receive the highest click revenue (mobile, desktop) and how much was it per week?
"""

#The columns necessary for this exercise are the following:
q1b = clicks[["device_type","click_revenue_dollars", "ds"]]

print(q1b)

#Let's take a first look at this dataframe info

q1b.info()

#Converting the ds column into datetime
q1b['ds'] = pd.to_datetime(q1b['ds'])

q1b.info()

#Now we'll generate a column containing the weeks necessary for our analysis
q1b["year_week"] = q1b["ds"].dt.strftime('%Y-%V')
print(q1b)

#The highest click revenue comes from Mobile:
df1 = q1b.groupby(['device_type'], sort=False)['click_revenue_dollars'].sum()

print(df1)

#Grouping the results by device and week
df2 = q1b.groupby(['device_type', 'year_week'], sort=False)['click_revenue_dollars'].sum()

print(df2)

#I decided to plot the results to have a better visualization of the results.
ax = df2.plot.barh()

ax.bar_label(ax.containers[0])

"""The device with the highest click revenue is the Mobile, with 314661.75. When plotting it by week, the highest results are:

*   week 52/2020: Mobile
*   week 53/2020: Mobile
*   week 01/2021: Desktop

# Which partner (provider_id) has the best ROAS (Return on ad spend)? Looking at the data do you have an idea why?
(For this question only include partners that have received a significant amount of traffic.)
"""

# Calculate clicks per provider and filter the providers with the highest amount of clicks
clicks_per_provider = clicks.groupby('provider_id').agg({'click_file_key': 'count'}).sort_values('click_file_key', ascending=False)
top_providers = clicks_per_provider.head(5).index.tolist()

print(top_providers)

# Filter the click data and bookings for the top providers
click_data_filtered = clicks[clicks.provider_id.isin(top_providers)].sample(frac=0.01, random_state=1)

bookings_filtered = bookings[bookings.provider_id.isin(top_providers)].sample(frac=0.01, random_state=1)

"""Note: I decided to work with samples in this exercise to improve efficiency as the dataframes felt too heavy and the sessions were crashing constantly. Sampling is the way I found to proceed with the analysis without any issues."""

# Merge or join the filtered dataframes on the common column(s)
merged_data = bookings_filtered.merge(click_data_filtered, on='provider_id')

# Calculate ROAS per provider
roas = []
for provider_id in top_providers:
    # Calculate the total cost per provider
    cost_per_provider = merged_data.groupby(['provider_id', 'cc_cpc']).size().reset_index(name='click_count')
    cost_per_provider['total_cost'] = cost_per_provider['cc_cpc'] * cost_per_provider['click_count']
    cost_per_provider = cost_per_provider.groupby('provider_id')['total_cost'].sum().reset_index()

    # Calculate the total revenue per provider
    revenue_per_provider = merged_data.groupby('provider_id')['gbv_usd'].sum().reset_index()

    # Calculate ROAS for the provider
    roas.append((revenue_per_provider-(cost_per_provider)) / (cost_per_provider))

# Get the index of the provider with the best ROAS
best_roas_index = np.argmax(roas)

# Get the provider_id with the best ROAS
best_roas_provider = top_providers[best_roas_index]

print("The provider with the best ROAS is:", best_roas_provider)

"""Getting more information on the provider with highest ROAS"""

# Filter the merged_data DataFrame for provider 7994 bookings
provider_7994_bookings = merged_data[merged_data['provider_id'] == 7994]

provider_7994_bookings.head()

# Explore and analyze the characteristics of the bookings
# Example analysis: length of stay
average_length_of_stay = provider_7994_bookings['length_of_stay_y'].mean()
max_length_of_stay = provider_7994_bookings['length_of_stay_y'].max()
min_length_of_stay = provider_7994_bookings['length_of_stay_y'].min()

# Histogram of length of stay
provider_7994_bookings['length_of_stay_y'].hist(bins=10)

# Summary statistics: Average length of stay
print(f"Average Length of Stay for Provider 7994: {average_length_of_stay:.2f} nights")
print(f"Maximum Length of Stay for Provider 7994: {max_length_of_stay} nights")
print(f"Minimum Length of Stay for Provider 7994: {min_length_of_stay} nights")

# Filter the merged_data DataFrame for provider 7994
provider_7994_data = merged_data[merged_data['provider_id'] == 7994]

# Calculate the revenue per country for provider 7994
revenue_by_country = provider_7994_data.groupby('hotel_country_name')['gbv_usd'].sum().reset_index()

# Sort the revenue in descending order
revenue_by_country = revenue_by_country.sort_values('gbv_usd', ascending=False)

# Print the countries where provider 7994 generates the most revenue
top_countries = revenue_by_country.head(5)['hotel_country_name']
print(f"The top countries where provider 7994 generates the most revenue are:\n{top_countries}")

# Calculate total cost per country for provider 7994
cost_by_country = provider_7994_data.groupby('hotel_country_name')['cc_cpc'].sum().reset_index()

# Create a DataFrame to store the comparison results
country_stats = pd.DataFrame({
    'hotel_country_name': revenue_by_country['hotel_country_name'],
    'total_revenue': revenue_by_country['gbv_usd'],
    'total_cost': cost_by_country['cc_cpc']
})

# Sort the countries by revenue in descending order
country_stats = country_stats.sort_values('total_revenue', ascending=False)

# Print the comparison results
print(f"\nPerformance of provider 7994 in different countries:\n{country_stats}")

# Calculate the number of bookings per country for provider 7994
bookings_by_country = provider_7994_bookings.groupby('hotel_country_name')['file_key'].count().reset_index()

# Sort the bookings in descending order
bookings_by_country = bookings_by_country.sort_values('file_key', ascending=False)

# Print the countries where provider 7994 gets more bookings
top_countries = bookings_by_country.head(5)['hotel_country_name']
print(f"The top countries where provider 7994 gets more bookings are:\n{top_countries}")

# Filter the merged_data DataFrame for the top 5 providers
top_5_providers = [7994, 8054, 8049, 8512, 10581]
filtered_data = merged_data[merged_data['provider_id'].isin(top_5_providers)]

# Calculate the total revenue per provider
revenue_per_provider = filtered_data.groupby('provider_id')['gbv_usd'].sum().reset_index()

# Calculate the total bookings per provider
bookings_per_provider = filtered_data.groupby('provider_id')['file_key'].count().reset_index()

# Calculate the average revenue per booking for each provider
average_revenue_per_booking = revenue_per_provider['gbv_usd'] / bookings_per_provider['file_key']

# Display the comparison results
comparison_df = pd.DataFrame({
    'Provider': top_5_providers,
    'Total Revenue': revenue_per_provider['gbv_usd'],
    'Total Bookings': bookings_per_provider['file_key'],
    'Avg. Revenue per Booking': average_revenue_per_booking
})
print(comparison_df)

"""The provider 7994 is the one with the highest ROAS. My hypothesis is that this provider has really strategic locations, in countries with a lot of tourism and business markets, specially the US and Brazil. Also, when compared with the other providers, 7994 has a way higher number of bookings, with a great avg revenue per booking. It is possible that this provider benefited from the multipliers to increase ROAS.

# What is the ratio of Domestic to International gross booking value?
"""

# Commented out IPython magic to ensure Python compatibility.
#Load Sqlite Extension

# %load_ext sql

# Commented out IPython magic to ensure Python compatibility.
# #Connect to Sqlite Database
# 
# %%sql
# sqlite:///test.db

#connect to sqlite db and send csv data to sqlite table
import sqlite3 as sql
conn = sql.connect('/content/test.db')

#Including the clicks dataframe in the new db

clicks.to_sql('clicks', conn)

#Including the bookings dataframe in the new db

bookings.to_sql('bookings', conn)

#Total GBV for domestic and international bookings
#For international I considered that bookings which user country and hotel country are different,
#and domestic for the opposite

pd.read_sql('select round(sum(b.gbv_usd),2) as domestic, round((select sum(b.gbv_usd) from bookings b left join clicks c on c.hotel_id=b.hotel_id where b.user_country_name != c.hotel_country_name),2) as international from bookings b left join clicks c on c.hotel_id=b.hotel_id where b.user_country_name = c.hotel_country_name', conn)

#Domestic GBV / International GBV

pd.read_sql('with test as (select sum(b.gbv_usd) as domestic, (select sum(b.gbv_usd) from bookings b left join clicks c on c.hotel_id=b.hotel_id where b.user_country_name != c.hotel_country_name) as international from bookings b left join clicks c on c.hotel_id=b.hotel_id where b.user_country_name = c.hotel_country_name) select round(domestic/international, 2) as ratio from test', conn)

"""# Create a chart for daily click and booking trends"""

# Load the data and take samples
clicks_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/tripadvisor/Test data/candidate_sql_test_click_data.csv', parse_dates=['ds']).sample(frac=0.1, random_state=1)
bookings_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/tripadvisor/Test data/candidate_sql_test_booking_data.csv', parse_dates=['conversion_date']).sample(frac=0.1, random_state=1)

# Group the Clicks and Bookings data by date and count the number of occurrences
clicks_per_day = clicks_df.groupby(clicks_df['ds'].dt.date)['click_file_key'].count()
bookings_per_day = bookings_df.groupby(bookings_df['conversion_date'].dt.date)['file_key'].count()

# Align the lengths of the clicks and bookings arrays
common_dates = set(clicks_per_day.index).intersection(bookings_per_day.index)
clicks_per_day = clicks_per_day[clicks_per_day.index.isin(common_dates)]
bookings_per_day = bookings_per_day[bookings_per_day.index.isin(common_dates)]

# Calculate the correlation between clicks and bookings
correlation = np.corrcoef(clicks_per_day.values, bookings_per_day.values)[0, 1]

# Create a line chart to visualize the daily click and booking trends
plt.figure(figsize=(12, 6))

# Plot the clicks line with blue color, solid line style, and label
plt.plot(clicks_per_day.index, clicks_per_day.values, color='blue', linestyle='-', label='Clicks')

# Plot the bookings line with green color, dashed line style, and label
plt.plot(bookings_per_day.index, bookings_per_day.values, color='green', linestyle='--', label='Bookings')

# Customize the appearance of the chart
plt.xlabel('Date')
plt.ylabel('Count')
plt.title('Daily Click and Booking Trends\nCorrelation: {:.2f}'.format(correlation))
plt.legend(loc='upper left')
plt.grid(True, linestyle='--', alpha=0.5)

# Rotate x-axis tick labels for better visibility
plt.xticks(rotation=45)

# Display the chart
plt.show()

"""# Create a chart showing daily average cost per click (cpc) for the top 5 providers"""

# Step 1: Filter the merged data for the top 5 providers
filtered_data = merged_data[merged_data['provider_id'].isin(top_5_providers)]

# Step 2: Group the filtered data by date and provider, and calculate average CPC
avg_cpc_per_day = filtered_data.groupby(['ds', 'provider_id'])['click_revenue_dollars'].mean().unstack()

# Step 3: Create line plots for each provider
plt.figure(figsize=(12, 6))

for provider_id in avg_cpc_per_day.columns:
    plt.plot(avg_cpc_per_day.index, avg_cpc_per_day[provider_id], label='Provider {}'.format(provider_id))

# Step 4: Customize the appearance of the chart
plt.xlabel('Date')
plt.ylabel('Average CPC')
plt.title('Daily Average Cost per Click (CPC) for Top 5 Providers')
plt.legend(loc='upper left')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=45)

# Display the chart
plt.show()

"""# Create a visualization showing click distribution for provider 7994 by country"""

# Filter the merged data for Provider 7994
provider_7994_data = merged_data[merged_data['provider_id'] == 7994]

provider_7994_data.head()

# Group the data by country and count the clicks
clicks_by_country = provider_7994_data['user_country_name_x'].value_counts()

# Plot the click distribution
plt.figure(figsize=(12, 6))
clicks_by_country.plot(kind='bar', color='skyblue')

# Customize the appearance of the chart
plt.xlabel('Country', fontsize=12)
plt.ylabel('Number of Clicks', fontsize=12)
plt.title('Click Distribution for Provider 7994 by Country', fontsize=14)
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(fontsize=10)
plt.grid(axis='y', linestyle='--', alpha=0.5)

# Display the chart
plt.tight_layout()
plt.show()

"""# Create a visualization showing daily conversion rate trends"""

# Calculate the daily conversion rate
daily_conversion_rate = bookings_df.groupby('conversion_date')['file_key'].count() / clicks_df.groupby('ds')['click_file_key'].count()

# Plot the conversion rate trends
plt.figure(figsize=(12, 6))
line = plt.plot(daily_conversion_rate, color='blue', linewidth=2, label='Conversion Rate')

# Add labels to the line
for x, y in zip(daily_conversion_rate.index, daily_conversion_rate.values):
    plt.text(x, y, f'{y:.2%}', ha='center', va='bottom', fontsize=8)

# Customize the appearance of the chart
plt.xlabel('Date', fontsize=12)
plt.ylabel('Conversion Rate', fontsize=12)
plt.title('Daily Conversion Rate Trends', fontsize=14)
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(fontsize=10)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.legend(loc='best')

# Display the chart
plt.tight_layout()
plt.show()

"""# Scenario: In the current dataset schema, you notice a consistent trend in click revenue over 4 weeks, and saw a sharp drop in the 5th week. What are a few areas you would look into and how would you cut the data to try and understand what’s happening? Note: the decrease is not visible in the dataset but the dataset should be used to help inform what information you would have access to at Tripadvisor if you had to respond to this type of situation.

Data Integrity Check: Examine the quality and completeness of the dataset by assessing data gaps, inconsistencies, or anomalies. Validate that the dataset accurately represents the click revenue data for the specified timeframe. This step ensures that the analysis is based on reliable and accurate data.

Temporal Analysis: Break down the click revenue data into smaller time intervals, such as daily or hourly, to identify specific periods within the fifth week where the drop occurred. Compare the revenue trends across different time intervals to pinpoint the timing and duration of the decline.

Segmentation Analysis: Segment the data based on relevant dimensions such as provider, country, device type, etc. Analyze the revenue trends within each segment to identify if the drop is specific to certain providers or countries.

Ad Performance Analysis: Assess the performance of ads and campaigns during the fifth week. Review metrics such as click-through rates, impressions, ad placements, and targeting options. Look for any significant changes or abnormalities in ad performance that could have contributed to the drop in revenue.

Also, I would comunicate with other areas within TripAdvisor, as they handle different areas and situations, they might have an idea of what caused the drop in click revenue.

Question 4

Our partners use “bid levers” to apply multipliers on hotel searches to influence how much they are willing to pay for a given click. The multiplier will either increase or reduce the cost per click (CPC). (For example: a partner may be willing to pay more or less per click depending on if a specified user action does or does not take place.)

When a user does not enter dates in their hotel search Tripadvisor will enter default check in and check out dates. For each resulting click the user’s entry will be recorded as such:
User does not enter check in/check out dates (default dates used) -> user_date_type= ‘def’
User enters check in / check out dates -> user_date_type = ‘user’.

# What is your hypothesis, would a partner attempt to increase or reduce their bid for a click that comes from default entered dates, and why?

My hypothesis would be that partners would likely try to reduce their bid for clicks that come from default entered dates. Here's my reasoning:

User Engagement: Clicks originating from default entered dates indicate that users did not actively provide their preferred check-in and check-out dates. This suggests that these users might be less engaged or still in the early stages of their hotel search.

Conversion Probability: Partners aim to maximize their return on investment by targeting users who are more likely to book hotels. Clicks from users who enter their own check-in and check-out dates show a higher level of intent and engagement, as they have taken the effort to specify their travel plans. These clicks are more likely to result in bookings compared to clicks from users with default dates.

Cost Efficiency: Partners want to optimize their advertising spend. Clicks from users with default entered dates might have a lower conversion probability, making them potentially less cost-efficient. By reducing their bid for these clicks, partners can lower their cost per click (CPC) and improve their overall advertising campaign's cost efficiency.

# The date type multiplier value i s applied when the user has not entered dates (user_date_type = ‘def’) , and it is recorded under ‘DD=n’ on field bid_multiplierdetail (i.e. ‘LOS=1.845,DTA=0.204, DD=0.688’).
In this example if the partner bids 1 for this click and the user does not enter days, the click revenue will end up being 0.688. Write a regular expression to extract default date multipliers and show how they would affect our click revenue.
"""

import re

# Example click revenue and bid amount
click_revenue = 1.0
bid_amount = 1.0

# Example bid_multiplierdetail string
bid_multiplierdetail = 'LOS=1.845,DTA=0.204, DD=0.688'

# Regular expression pattern to match default date multipliers
pattern = r'DD=([\d.]+)'

# Extract default date multipliers using regular expression
multipliers = re.findall(pattern, bid_multiplierdetail)

# Calculate the total multiplier effect on click revenue
multiplier_effect = 1.0
for multiplier in multipliers:
    multiplier_effect *= float(multiplier)

# Calculate the adjusted click revenue
adjusted_click_revenue = click_revenue * multiplier_effect

# Calculate the adjusted CPC (Cost Per Click)
adjusted_cpc = bid_amount * multiplier_effect

# Print the results
print(f"Default Date Multipliers: {multipliers}")
print(f"Total Multiplier Effect: {multiplier_effect:.3f}")
print(f"Adjusted Click Revenue: ${adjusted_click_revenue:.3f}")
print(f"Adjusted CPC: ${adjusted_cpc:.3f}")

"""Default date multipliers can affect click revenue by adjusting the cost per click (CPC) based on whether the user entered their own check-in and check-out dates or default dates were used. The regular expression can extract the default date multipliers from the 'bid_multiplierdetail' field and calculate their effect on click revenue.

In the given example, let's say the partner bids $1 for a click. If the user does not enter check-in and check-out dates, a default date multiplier of 0.688 is recorded in the 'bid_multiplierdetail' field. This means that the click revenue will end up being 0.688 times the original bid amount.

By applying the regular expression to extract the default date multipliers, we can calculate the total multiplier effect on click revenue. Each default date multiplier is multiplied together to obtain the total effect. This total multiplier is then used to adjust the click revenue.

For example, if the original click revenue is 1 and the default date multiplier is 0.688, the adjusted click revenue would be 1 * 0.688 = 0.688. This indicates that the default date multiplier reduces the click revenue by 31.2%.

# Which partners are using this multiplier to increase/decrease their bids and what is the total effect to the click revenue from them?
"""

# Filter the relevant columns for analysis
data = merged_data[['provider_id', 'bid_multiplierdetail']]

# Define a function to calculate the total effect on click revenue
def calculate_total_effect(multiplier_detail):
    # Extract default date multipliers using regular expression
    multipliers = re.findall(r"DD=([\d.]+)", str(multiplier_detail))

    # Calculate the total effect on click revenue if multipliers are present
    if multipliers:
        multipliers = np.array(multipliers, dtype=float)
        total_effect = np.prod(multipliers)
    else:
        total_effect = 1.0  # Default value if no multipliers found

    return total_effect

# Apply the function to each row in the dataframe to calculate the total effects
data['total_effect'] = data['bid_multiplierdetail'].apply(calculate_total_effect)

# Group the data by provider and calculate the sum of total effects
total_effects = data.groupby('provider_id')['total_effect'].sum()

# Determine if the total effect is an increase or decrease in click revenue
effect_type = np.where(total_effects > 1, 'Increase', 'Decrease')

# Create a new dataframe to store the results
results_df = pd.DataFrame({'Provider ID': total_effects.index, 'Effect Type': effect_type, 'Total Effect': total_effects})

# Print the partners using the multiplier and their total effects on click revenue
print(results_df)

"""# Is ROAS higher or lower when users do not enter dates (website sets default dates)?"""

# Filter the relevant columns for analysis
data = merged_data[['user_date_type', 'gbv_usd', 'cc_cpc']]

# Calculate the revenue per click
data['revenue_per_click'] = data['gbv_usd'] - data['cc_cpc']

# Group the data by user_date_type and calculate total revenue and cost
grouped_data = data.groupby('user_date_type').agg({'revenue_per_click': 'sum', 'cc_cpc': 'sum'})

# Calculate the ROAS for each group
grouped_data['roas'] = grouped_data['revenue_per_click'] / grouped_data['cc_cpc']

# Create a DataFrame to show the impact on ROAS
roas_impact = pd.DataFrame({
    'User Date Type': grouped_data.index,
    'Total Revenue': grouped_data['revenue_per_click'],
    'Total Cost': grouped_data['cc_cpc'],
    'ROAS': grouped_data['roas']
})

# Calculate the difference in ROAS between default dates and user-entered dates
roas_difference = roas_impact.loc['def', 'ROAS'] - roas_impact.loc['user', 'ROAS']

# Print the DataFrame and ROAS difference
print(roas_impact)
print("\nROAS Difference (Default Dates - User-Entered Dates):", roas_difference)

"""ROAS is lower when users do not enter dates."""